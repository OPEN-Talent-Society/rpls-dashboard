---
name: convex-backend
description: Full-stack TypeScript backend platform with reactive database, real-time synchronization, serverless functions, and file storage. Use for building real-time collaborative applications, AI-powered apps, task management, e-commerce, and any application requiring automatic data synchronization without manual WebSocket management.
---

# Convex Backend Platform

## Overview

Convex is a **full-stack TypeScript backend platform** that combines a reactive database, real-time synchronization, serverless functions, and file storage into a unified developer experience. It eliminates the need for state managers, cache invalidation policies, or manual WebSocket management by providing automatic real-time updates across all connected clients.

**When to Use Convex:**
- Real-time collaborative applications (chat, docs, whiteboards)
- AI-powered applications with RAG and streaming
- Task management and productivity tools
- E-commerce with live inventory
- Applications requiring automatic data synchronization
- Rapid prototyping and MVP development
- TypeScript-first teams wanting to avoid infrastructure management

**Key Value Propositions:**
- **Real-time by default:** All queries are reactive and automatically update when data changes
- **End-to-end type safety:** TypeScript from database schemas to API responses
- **Serverless functions:** Write backend logic in TypeScript/JavaScript without infrastructure management
- **Zero-configuration sync:** No WebSocket setup required - Convex handles all real-time coordination

## Prerequisites

**Installation:**
```bash
pnpm add convex
pnpm dlx convex dev --configure
```

**Environment Variables:**
```bash
# .env.local (auto-generated by convex dev)
CONVEX_DEPLOYMENT=dev:...
NEXT_PUBLIC_CONVEX_URL=https://...

# Production (set in CI/CD)
CONVEX_DEPLOY_KEY=prod_key_...  # From Convex dashboard
```

**TypeScript Version:**
- Requires TypeScript 5.0.3 or newer

## Core Capabilities

### 1. Reactive Database

Convex provides a **reactive document database** where queries are TypeScript code running directly in the database. Like React components react to state changes, Convex queries react to database changes.

**Architecture:**
```
Client Application
       ↓ (WebSocket)
Convex Query Tracker
       ↓
Reactive Database
       ↓
Auto-rerun on change → Push to clients
```

**Key Features:**
- Automatic dependency tracking
- Real-time updates when any dependency changes
- Persistent WebSocket connections
- Push-based updates (database pushes to clients)

### 2. Server Functions (Queries, Mutations, Actions)

#### **Queries** - Read Data (Deterministic)

**Purpose:** Retrieve data from the database
**Constraints:** Must be deterministic, read-only
**Real-time:** Automatically re-run when dependencies change

```typescript
// convex/tasks.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const getAllOpenTasks = query({
  args: {},
  handler: async (ctx, args) => {
    const tasks = await ctx.db
      .query("tasks")
      .withIndex("by_completed", (q) => q.eq("completed", false))
      .collect();
    return tasks;
  },
});
```

#### **Mutations** - Write Data (Deterministic, Transactional)

**Purpose:** Modify database state
**Constraints:** Must be deterministic, run in transactions
**Automatic rollback:** Entire function rolls back if exception thrown

```typescript
// convex/tasks.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const setTaskCompleted = mutation({
  args: { taskId: v.id("tasks"), completed: v.boolean() },
  handler: async (ctx, { taskId, completed }) => {
    await ctx.db.patch(taskId, { completed });
  },
});
```

#### **Actions** - External Operations (Non-deterministic)

**Purpose:** Execute non-deterministic code, call external APIs
**Capabilities:** Can execute any JavaScript, make HTTP requests, use Node.js libraries
**Database access:** Indirect via queries and mutations

```typescript
// convex/images.ts
import { action } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";

export const generateAndStore = action({
  args: { prompt: v.string() },
  handler: async (ctx, args) => {
    const imageUrl = await callExternalAPI(args.prompt);
    const response = await fetch(imageUrl);
    const image = await response.blob();

    const storageId = await ctx.storage.store(image);
    await ctx.runMutation(internal.images.storeResult, {
      storageId,
      prompt: args.prompt,
    });
  },
});
```

### 3. Database Schema Definition

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  messages: defineTable({
    author: v.id("users"),
    body: v.string(),
    timestamp: v.number(),
  })
    .index("by_author", ["author"])
    .index("by_timestamp", ["timestamp"]),

  users: defineTable({
    name: v.string(),
    email: v.string(),
    role: v.union(v.literal("admin"), v.literal("user")),
    lastActive: v.optional(v.number()),
  })
    .index("by_email", ["email"])
    .index("by_role_and_active", ["role", "lastActive"]),

  tasks: defineTable({
    text: v.string(),
    completed: v.boolean(),
    userId: v.id("users"),
  }).index("by_completed", ["completed"]),
});
```

**Schema Benefits:**
- Compile-time error detection
- Auto-generated types for all functions
- IDE autocomplete for database operations
- Refactoring safety across frontend and backend

## Common Operations

### Database CRUD Operations

#### **Create (Insert)**

```typescript
// Insert a single document
const taskId = await ctx.db.insert("tasks", {
  text: "Buy groceries",
  completed: false,
  userId: currentUserId,
});
```

#### **Read (Query)**

```typescript
// Get all documents
const allTasks = await ctx.db.query("tasks").collect();

// Get by ID
const task = await ctx.db.get(taskId);

// Get first matching document
const task = await ctx.db
  .query("tasks")
  .withIndex("by_completed", (q) => q.eq("completed", false))
  .first();

// Get unique document (throws if multiple found)
const user = await ctx.db
  .query("users")
  .withIndex("by_email", (q) => q.eq("email", "user@example.com"))
  .unique();

// Limit results
const recentTasks = await ctx.db
  .query("tasks")
  .order("desc")
  .take(10);

// Filter without index (use sparingly)
const tasks = await ctx.db
  .query("tasks")
  .filter((q) => q.eq(q.field("userId"), userId))
  .collect();
```

#### **Update (Patch/Replace)**

```typescript
// Partial update (patch)
await ctx.db.patch(taskId, {
  completed: true,
  completedAt: Date.now()
});

// Full replacement (all fields required)
await ctx.db.replace(taskId, {
  text: "Updated text",
  completed: true,
  userId: currentUserId,
});
```

#### **Delete**

```typescript
await ctx.db.delete(taskId);
```

### Indexes and Query Performance

#### **Using Indexes Efficiently**

```typescript
// WITHOUT index - Full table scan (slow for large tables)
const messages = await ctx.db
  .query("messages")
  .filter((q) => q.eq(q.field("author"), userId))
  .collect();

// WITH index - Fast O(log n) lookup
const messages = await ctx.db
  .query("messages")
  .withIndex("by_author", (q) => q.eq("author", userId))
  .collect();

// Range queries
const recentMessages = await ctx.db
  .query("messages")
  .withIndex("by_timestamp", (q) =>
    q.gt("timestamp", Date.now() - 86400000)
  )
  .collect();
```

#### **Pagination**

```typescript
import { paginationOptsValidator } from "convex/server";

export const listMessages = query({
  args: {
    paginationOpts: paginationOptsValidator,
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("messages")
      .order("desc")
      .paginate(args.paginationOpts);
  },
});

// Client usage
const { results, continueCursor } = await client.query(
  api.messages.listMessages,
  { paginationOpts: { numItems: 20 } }
);
```

### Authentication and Authorization

#### **Setup Authentication (Clerk Example)**

```typescript
// Client-side: Wrap app with ConvexProviderWithClerk
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { ClerkProvider, useAuth } from "@clerk/clerk-react";
import { ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

function App() {
  return (
    <ClerkProvider publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY!}>
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <YourApp />
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
}
```

#### **Server-side Authentication**

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";

export const getUserData = query({
  args: {},
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) =>
        q.eq("tokenIdentifier", identity.tokenIdentifier)
      )
      .unique();

    return user;
  },
});
```

#### **Authorization Patterns**

```typescript
// Restrict access to own data
export const deleteUserProfile = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const user = await getCurrentUser(ctx);
    if (user.role !== "admin") {
      throw new Error("Unauthorized");
    }

    // Proceed with operation
    await ctx.db.delete(user._id);
  },
});

// Use internal functions to prevent direct client access
import { internalMutation } from "./_generated/server";

export const internalCleanup = internalMutation({
  handler: async (ctx) => {
    // Can only be called from other Convex functions
    // Not exposed to client
  },
});
```

#### **React Authentication Components**

```typescript
import { Authenticated, Unauthenticated, AuthLoading } from "convex/react";

function App() {
  return (
    <>
      <Authenticated>
        <Dashboard />
      </Authenticated>
      <Unauthenticated>
        <LoginPage />
      </Unauthenticated>
      <AuthLoading>
        <LoadingSpinner />
      </AuthLoading>
    </>
  );
}
```

### File Storage

#### **Upload Files**

```typescript
// Client-side upload
import { useMutation } from "convex/react";
import { api } from "../convex/_generated/api";

export function FileUploader() {
  const generateUploadUrl = useMutation(api.files.generateUploadUrl);
  const saveFile = useMutation(api.files.saveFile);

  const handleUpload = async (file: File) => {
    // Get upload URL
    const uploadUrl = await generateUploadUrl();

    // Upload file
    const result = await fetch(uploadUrl, {
      method: "POST",
      headers: { "Content-Type": file.type },
      body: file,
    });

    const { storageId } = await result.json();

    // Save reference to database
    await saveFile({
      storageId,
      filename: file.name,
      contentType: file.type,
    });
  };

  return <input type="file" onChange={e => handleUpload(e.target.files[0])} />;
}

// convex/files.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const generateUploadUrl = mutation({
  handler: async (ctx) => {
    return await ctx.storage.generateUploadUrl();
  },
});

export const saveFile = mutation({
  args: {
    storageId: v.id("_storage"),
    filename: v.string(),
    contentType: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    await ctx.db.insert("files", {
      storageId: args.storageId,
      filename: args.filename,
      contentType: args.contentType,
      uploadedBy: identity.subject,
      uploadedAt: Date.now(),
    });
  },
});
```

#### **Retrieve and Delete Files**

```typescript
// Get URL for file
const url = await ctx.storage.getUrl(storageId);

// Get file as Blob
const blob = await ctx.storage.get(storageId);

// Delete file
export const deleteFile = mutation({
  args: { storageId: v.id("_storage") },
  handler: async (ctx, args) => {
    await ctx.storage.delete(args.storageId);
  },
});
```

### Scheduled Functions (Cron Jobs)

```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Every minute
crons.interval(
  "clear messages table",
  { minutes: 1 },
  internal.messages.clearAll
);

// Every 30 seconds
crons.interval(
  "Clear presence data",
  { seconds: 30 },
  internal.presence.clear
);

// Daily at specific time (UTC)
crons.daily(
  "Reset high scores",
  {
    hourUTC: 17,
    minuteUTC: 30,
  },
  internal.scores.reset
);

// Weekly
crons.weekly(
  "Weekly re-engagement email",
  {
    dayOfWeek: "Tuesday",
    hourUTC: 17,
    minuteUTC: 30,
  },
  internal.emails.send
);

// Monthly
crons.monthly(
  "payment reminder",
  {
    day: 1,
    hourUTC: 16,
    minuteUTC: 0
  },
  internal.payments.sendPaymentEmail,
  { email: "billing@example.com" }
);

// Custom cron syntax (minute hour day_of_month month day_of_week)
crons.cron(
  "custom schedule",
  "0 16 1 * *",  // Every month on 1st at 16:00 UTC
  internal.tasks.cleanup
);

export default crons;
```

## CLI Commands

### Development

```bash
# Initialize Convex project
pnpm dlx convex dev

# Configure deployment
pnpm dlx convex dev --configure

# Run development server (watches for changes)
pnpm dlx convex dev

# Run dev once (for CI)
pnpm dlx convex dev --once
```

### Deployment

```bash
# Deploy to production
pnpm dlx convex deploy

# Deploy with pre-build commands
pnpm dlx convex deploy --cmd "pnpm run build"

# Create preview deployment
pnpm dlx convex deploy --preview-create my-branch-name

# Deploy in CI/CD (requires CONVEX_DEPLOY_KEY)
CONVEX_DEPLOY_KEY="YOUR_KEY" pnpm dlx convex deploy
```

### Environment Variables

```bash
# List environment variables
pnpm dlx convex env list

# Get specific variable
pnpm dlx convex env get <name>

# Set variable
pnpm dlx convex env set <name> <value>

# Remove variable
pnpm dlx convex env remove <name>
```

### Backup and Restore

```bash
# Export all data to ZIP file
pnpm dlx convex export --path ~/Downloads

# Restore from backup (DESTRUCTIVE - creates backup first)
pnpm dlx convex restore --path <path_to_backup.zip>
```

## Client Integration

### React (Recommended)

```typescript
// app/ConvexClientProvider.tsx
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: React.ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}

// Component usage
import { useQuery, useMutation } from "convex/react";
import { api } from "../convex/_generated/api";

function TaskList() {
  // Subscribe to query (auto-updates)
  const tasks = useQuery(api.tasks.list);

  // Get mutation function
  const addTask = useMutation(api.tasks.add);

  if (tasks === undefined) return <div>Loading...</div>;

  return (
    <div>
      {tasks.map(task => <div key={task._id}>{task.text}</div>)}
      <button onClick={() => addTask({ text: "New task" })}>
        Add Task
      </button>
    </div>
  );
}
```

### Next.js App Router (Server Components)

```typescript
// app/tasks/page.tsx
import { fetchQuery } from "convex/nextjs";
import { api } from "../../convex/_generated/api";

export default async function TasksPage() {
  const tasks = await fetchQuery(api.tasks.list);

  return (
    <div>
      {tasks.map(task => <div key={task._id}>{task.text}</div>)}
    </div>
  );
}
```

### JavaScript/Node.js (HTTP Client)

```typescript
import { ConvexHttpClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

const client = new ConvexHttpClient(process.env.CONVEX_URL);

// One-off query
const messages = await client.query(api.messages.list);

// One-off mutation
await client.mutation(api.messages.send, {
  body: "Hello!",
  author: "me"
});
```

### Real-time Subscription Client

```typescript
import { ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

const client = new ConvexClient(process.env.CONVEX_URL);

// Subscribe to updates
const unsubscribe = client.onUpdate(
  api.messages.list,
  {},
  (messages) => {
    console.log("New messages:", messages);
  }
);

// Later: unsubscribe
unsubscribe();
```

### HTTP API (Server-to-Server)

```bash
# Query endpoint
POST https://YOUR_DEPLOYMENT.convex.cloud/api/query

# Request body
{
  "path": "messages:list",
  "args": { "limit": 10 },
  "format": "json"
}

# Success response
{
  "status": "success",
  "value": [ /* query results */ ],
  "logLines": []
}

# Error response
{
  "status": "error",
  "errorMessage": "Function not found",
  "errorData": {},
  "logLines": []
}
```

## Best Practices

### Schema Design

**DO:**
- Define schemas for all tables for type safety
- Use indexes for frequently queried fields
- Keep document sizes reasonable (<1MB)
- Use nullable fields for optional data
- Index compound fields for common query patterns

**DON'T:**
- Over-index (max 32 indexes per table, but fewer is better)
- Use redundant indexes (e.g., `by_foo` when you have `by_foo_and_bar`)
- Store large binary data in documents (use file storage instead)
- Create circular references without making one field nullable

```typescript
// GOOD: Efficient schema with strategic indexes
export default defineSchema({
  users: defineTable({
    name: v.string(),
    email: v.string(),
    role: v.union(v.literal("admin"), v.literal("user")),
    lastActive: v.optional(v.number()),
  })
    .index("by_email", ["email"])
    .index("by_role_and_active", ["role", "lastActive"]),
});

// BAD: Redundant indexes
export default defineSchema({
  users: defineTable({
    name: v.string(),
    email: v.string(),
  })
    .index("by_name", ["name"])
    .index("by_name_and_email", ["name", "email"]), // Redundant!
});
```

### Query Optimization

**Always use indexes for large tables:**

```typescript
// BAD: Full table scan + filter
const users = await ctx.db
  .query("users")
  .collect()
  .filter(u => u.role === "admin"); // Scans entire table!

// GOOD: Index-based query
const admins = await ctx.db
  .query("users")
  .withIndex("by_role", (q) => q.eq("role", "admin"))
  .collect(); // Only scans matching documents
```

**Use pagination for large datasets:**

```typescript
export const listItems = query({
  args: { paginationOpts: paginationOptsValidator },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("items")
      .order("desc")
      .paginate(args.paginationOpts);
  },
});
```

### Function Design

**Mutations vs Actions:**

```typescript
// GOOD: Mutation schedules action
export const createOrder = mutation({
  args: { productId: v.id("products") },
  handler: async (ctx, args) => {
    // Write to database
    const orderId = await ctx.db.insert("orders", {
      productId: args.productId,
      status: "pending",
    });

    // Schedule action for external processing
    await ctx.scheduler.runAfter(0, internal.orders.processPayment, {
      orderId,
    });

    return orderId;
  },
});

// Action handles external API
export const processPayment = internalAction({
  args: { orderId: v.id("orders") },
  handler: async (ctx, args) => {
    // Call payment gateway
    const result = await callPaymentAPI(args.orderId);

    // Update database via mutation
    await ctx.runMutation(internal.orders.updateStatus, {
      orderId: args.orderId,
      status: result.status,
    });
  },
});
```

### Error Handling

```typescript
// Mutations automatically rollback on error
export const transferFunds = mutation({
  args: {
    fromAccount: v.id("accounts"),
    toAccount: v.id("accounts"),
    amount: v.number(),
  },
  handler: async (ctx, args) => {
    const from = await ctx.db.get(args.fromAccount);
    if (!from || from.balance < args.amount) {
      throw new Error("Insufficient funds"); // Entire transaction rolls back
    }

    // These updates are atomic
    await ctx.db.patch(args.fromAccount, {
      balance: from.balance - args.amount,
    });
    await ctx.db.patch(args.toAccount, {
      balance: (await ctx.db.get(args.toAccount))!.balance + args.amount,
    });
  },
});

// Client-side error handling
try {
  await client.mutation(api.accounts.transferFunds, {
    fromAccount,
    toAccount,
    amount: 100,
  });
} catch (error) {
  console.error("Transfer failed:", error);
  // Show user-friendly error message
}
```

### Security Best Practices

```typescript
// Always verify authentication for sensitive operations
export const deleteAccount = mutation({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Additional authorization check
    const user = await getCurrentUser(ctx);
    if (user.role !== "admin") {
      throw new Error("Unauthorized");
    }

    // Proceed with operation
  },
});

// Use internal functions to prevent direct client access
export const internalCleanup = internalMutation({
  handler: async (ctx) => {
    // Can only be called from other Convex functions
    // Not exposed to client
  },
});
```

### Development Workflow

**Team Collaboration:**
1. Each developer runs `pnpm dlx convex dev` for personal dev deployment
2. Changes tested in individual dev environment
3. Code reviewed and merged to main branch
4. Automated CI/CD deploys to production via `pnpm dlx convex deploy`

**Preview Deployments:**
- Use preview deployments for testing backend changes
- Combine with Vercel/Netlify preview for full-stack testing

## Common Use Cases

### Real-time Chat Application

```typescript
// convex/schema.ts
export default defineSchema({
  messages: defineTable({
    author: v.string(),
    body: v.string(),
    room: v.string(),
  })
    .index("by_room", ["room"])
    .index("by_room_and_time", ["room", "_creationTime"]),
});

// convex/messages.ts
export const listMessages = query({
  args: { room: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("messages")
      .withIndex("by_room", (q) => q.eq("room", args.room))
      .order("desc")
      .take(100);
  },
});

export const sendMessage = mutation({
  args: {
    room: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    await ctx.db.insert("messages", {
      room: args.room,
      body: args.body,
      author: identity.name ?? "Anonymous",
    });
  },
});
```

### User Registration and Profile Management

```typescript
export const createUser = mutation({
  args: {
    name: v.string(),
    email: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Check if user already exists
    const existing = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", args.email))
      .unique();

    if (existing) {
      throw new Error("User already exists");
    }

    // Create user
    const userId = await ctx.db.insert("users", {
      name: args.name,
      email: args.email,
      tokenIdentifier: identity.tokenIdentifier,
      createdAt: Date.now(),
    });

    return userId;
  },
});
```

### Scheduled Background Jobs

```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Daily cleanup of old data
crons.daily(
  "cleanup old messages",
  { hourUTC: 2, minuteUTC: 0 },
  internal.maintenance.cleanupOldMessages
);

// Hourly analytics aggregation
crons.hourly(
  "aggregate analytics",
  { minuteUTC: 0 },
  internal.analytics.aggregate
);

export default crons;

// convex/maintenance.ts
export const cleanupOldMessages = internalMutation({
  handler: async (ctx) => {
    const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    const oldMessages = await ctx.db
      .query("messages")
      .withIndex("by_creation_time", (q) =>
        q.lt("_creationTime", oneWeekAgo)
      )
      .collect();

    for (const message of oldMessages) {
      await ctx.db.delete(message._id);
    }
  },
});
```

## Troubleshooting

### Common Issues

**Issue: "Function not found" error**
- Ensure `pnpm dlx convex dev` is running
- Check function is exported from convex directory
- Verify import path in `api` object

**Issue: Type errors in client code**
- Run `pnpm dlx convex dev` to regenerate types
- Check `convex/_generated/` directory exists
- Ensure TypeScript version >= 5.0.3

**Issue: Query not updating in real-time**
- Verify using `useQuery` hook (not one-off HTTP client)
- Check WebSocket connection in browser DevTools
- Ensure mutation is actually changing queried data

**Issue: "Not authenticated" errors**
- Verify auth provider is configured correctly
- Check `ConvexProviderWithClerk` wraps app
- Ensure `getUserIdentity()` is awaited

**Issue: Slow queries**
- Add indexes for frequently queried fields
- Use `.take(n)` to limit results
- Implement pagination for large datasets
- Avoid `.filter()` after `.collect()` - use indexes instead

**Issue: Bandwidth limits hit**
- Monitor usage in Convex dashboard
- Implement pagination to reduce data transfer
- Use `.take(n)` to limit scanned rows
- Consider upgrading to paid plan

### Performance Optimization

**Index Usage:**
- Always use `withIndex()` for queries on large tables (1000+ documents)
- Use `.first()`, `.unique()`, or `.take(n)` to limit scanned rows
- Avoid `.filter()` after `.collect()` - use indexes instead

**Bandwidth Management:**
- Real-time queries consume bandwidth on every update
- Monitor bandwidth usage in dashboard
- Use pagination to reduce data transfer
- Consider debouncing rapid updates

**Function Execution:**
- Keep mutations focused and fast
- Use actions for long-running external operations
- Schedule heavy work with `ctx.scheduler.runAfter()`

## Limitations and Constraints

**Technical Limits:**
- Maximum 32 indexes per table
- Maximum 16 fields per index
- Maximum document size: ~1MB (recommended)
- `_creationTime` automatically added to end of every index

**Free Plan Limits:**
- Database bandwidth: 1 GB/month
- Storage: 1 GB
- Limited function execution time
- After limits hit, new mutations may fail

**Paid Plans (Professional):**
- No hard resource limits
- Scales to billions of documents, TBs of storage
- Limits can be lifted on case-by-case basis

**Query Constraints:**
- Queries and mutations must be deterministic
- Cannot use `Math.random()`, `Date.now()` in queries/mutations
- Actions have network latency for database access

## Integration Ecosystem

### Authentication Providers
- **Clerk** (Recommended)
- **Auth0**
- **Better Auth** (via Convex Component)
- **Custom JWT providers**
- **Database-based auth**

### Frontend Frameworks
- React (best support)
- Next.js (App Router + Pages Router)
- Remix
- Vue.js (via @convex-dev/convex-vue)
- Svelte (via @get-convex/convex-svelte)
- Expo (React Native)

### Convex Components (Pre-built)
- **RAG** - Retrieval-Augmented Generation
- **Agent** - AI agent workflows
- **Resend** - Email service integration
- **Aggregate** - Efficient counts and sums
- **Rate Limiter** - Application-level rate limiting
- **Workpool** - Parallel action execution
- **Migrations** - Database migration management
- **Crons** - Dynamic cron job registration
- **Geospatial** - Geospatial indexing
- **Action Cache** - Cache expensive function results

## Resources

### Official Documentation
- **Website:** https://www.convex.dev/
- **Documentation:** https://docs.convex.dev/
- **Stack Blog:** https://stack.convex.dev/
- **GitHub:** https://github.com/get-convex
- **Templates:** https://www.convex.dev/templates
- **NPM Package:** https://www.npmjs.com/package/convex

### Key Documentation Pages
- [Best Practices](https://docs.convex.dev/understanding/best-practices/)
- [Indexes and Query Performance](https://docs.convex.dev/database/reading-data/indexes/indexes-and-query-perf)
- [Production Deployment](https://docs.convex.dev/production)
- [Limits](https://docs.convex.dev/production/state/limits)
- [Authentication](https://docs.convex.dev/auth/)
- [CLI Reference](https://docs.convex.dev/cli)

### Community
- **Discord Community:** Active developer community
- **GitHub Discussions:** https://github.com/get-convex/convex-backend/discussions
- **GitHub Issues:** https://github.com/get-convex/convex-backend/issues

## When to Use Convex vs Alternatives

### Use Convex When:
- Building real-time collaborative applications
- Need automatic data synchronization
- TypeScript-first team
- Want to avoid infrastructure management
- Rapid prototyping and MVP development
- AI-powered applications with RAG

### Consider Alternatives When:
- Need direct SQL access or complex queries
- Require specific database features (e.g., PostGIS)
- Have existing PostgreSQL/MySQL expertise
- Need complete vendor independence
- Building purely static sites

---

**Skill Version:** 1.0
**Last Updated:** December 9, 2025
**Based on:** Convex 1.30.0 and comprehensive platform research
